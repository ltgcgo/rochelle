"use strict";let d={0:"\0",a:"\x07",b:"\b",e:"\x1B",f:"\f",n:`
`,r:"\r",t:"	",v:"\v","\\":"\\","'":"'",'"':'"'},u=new Uint8Array(128);u.fill(1,48,58);u.fill(1,65,71);u.fill(1,97,103);let f=new Uint8Array(256);f.fill(1,0,32);f.fill(1,128,160);f[127]=1;let A={};for(let n in d){let r=d[n];A[r]=`\\${n}`,f[r.charCodeAt(0)]=2}f[34]=3;f[39]=3;let h=n=>{let r="",i=!1;for(let l=0;l<n.length;l++){let s=n[l];if(i){let t=0;switch(s){case"x":{t=2;break}case"u":{t=4;break}case"U":{t=8;break}default:{let a=d[s];if(typeof a=="string")r+=a;else throw new Error(`Invalid escape identifier "${s}" at index ${l}`);i=!1;continue}}if(t>0){let a=l+1,e=n.substring(a,a+t);if(e.length<t)throw new RangeError(`Insufficient code point buffer "${e}" at index ${a}`);let o=parseInt(e,16);if(Number.isNaN(o))throw new RangeError(`Malformed code point representation "${e}" at index ${a}`);if(o>=1114112)throw new RangeError(`Code point "${e}" exceeds 0x10ffff at index ${a}`);r+=String.fromCodePoint(o),i=!1,l+=t}}else s==="\\"?i=!0:r+=s}return r},g=(n,r=0)=>{};self.TextEscape=g;let w=class{static MASK_TYPE=3;static MASK_DATA=12;static TYPE_TSV=0;static TYPE_CSV=1;static DATA_TEXT=0;static DATA_JSON=4;static parse(r,i){let l=r&this.MASK_TYPE,s=r&this.MASK_DATA,t=0,a=0,e,o=0,x,c=i.getReader();return new ReadableStream({pull:async T=>{let{value:b,done:y}=await c.read();if(typeof b=="string"){switch(l){case this.TYPE_TSV:{e=[];try{for(let p of b.split("	"))switch(s){case this.DATA_TEXT:{e.push(h(p));break}case this.DATA_JSON:{e.push(t===0?h(p):JSON.parse(p));break}default:throw new TypeError(`Unknown DSV value type ${l}`)}}catch(p){console.debug(`The following error appeared when parsing on line ${t+1}.`),console.error(p)}break}case this.TYPE_CSV:{if(s!==this.DATA_TEXT)throw new TypeError(`Invalid type ${l} for CSV, only plain text is allowed`);break}default:throw new TypeError(`Unknown DSV type ${l}`)}T.enqueue(e),t++}y&&T.close()}})}static parseObjects(r,i){let l=0,s=this.parse(r,i).getReader(),t;return new ReadableStream({start:async a=>{let{value:e,done:o}=await s.read();typeof e?.length=="number"&&(t=e),o&&a.close()},pull:async a=>{let{value:e,done:o}=await s.read();if(typeof e?.length=="number"){let x={};for(let c=0;c<e.length;c++)e[c]&&(x[t[c]]=e[c]);a.enqueue(x)}o&&a.close()}})}};export{w as default};
